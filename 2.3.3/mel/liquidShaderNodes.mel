/**
 *
 * The contents of this file are subject to the Mozilla Public License Version 1.1 (the
 * "License"); you may not use this file except in compliance with the License. You may
 * obtain a copy of the License at http: *www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis, WITHOUT
 * WARRANTY OF ANY KIND, either express or implied. See the License for the specific
 * language governing rights and limitations under the License.
 *
 * The Original Code is the Liquid Rendering Toolkit.
 *
 * The Initial Developer of the Original Code is Colin Doncaster. Portions created by
 * Colin Doncaster are Copyright (C) 2002. All Rights Reserved.
 *
 * Contributor(s): Philippe Leprince.
 *
 *
 * The RenderMan (R) Interface Procedures and Protocol are:
 * Copyright 1988, 1989, Pixar
 * All Rights Reserved
 *
 *
 * RenderMan (R) is a registered trademark of Pixar
 *
 *  Creation Date:  June 20, 2000
 *
 *
 *  Description:
 *      Liquids Shader Nodes procedures.
 *
 */
source xxliquidutility.mel;

global string $gLiquidAELastShader;
global string $gLiquidAELastNode;

// TODO : store the shaderMethods as well

/**
 *  Stores extra data about the shader that will be needed at RIB export time.
 *  Also stores a sequence of lif commands to create/reconnect widgets
 */
proc rmanParams_create( string $node, int $reReadShaderParams )
{
  liqPushIdent();
	liqlog("rmanParams_create(...)");
  if ( $reReadShaderParams ) {
    string $shaderPath = `getAttr ($node+".rmanShaderLong")`;
    liquidSlInfoReset(); // force reload
    liquidSlSetShader( $shaderPath );
  }

  //trace ("[rmanParams_create] for "+$node+", reread: "+$reReadShaderParams);

  global string $gLifCmdList[];

  setAttr -type "string" ( $node + ".rmanShader" ) (liquidSlShaderName());

  // store the output values
  //
  string $cmd = ( "setAttr -type Int32Array " + $node + ".rmanIsOutput " + liquidSlNumParams() + " " );
  for ( $i = 0; $i < liquidSlNumParams(); $i++ ) {
      $cmd += ( "" + liquidSlParamIsOutput($i) + " " );
  }
  //trace $cmd;
  eval $cmd;

  // store the method names
  //
  string $cmd = ( "setAttr -type stringArray " + $node + ".rmanMethods " + liquidSlNumMethods() + " " );
  for ( $i = 0; $i < liquidSlNumMethods(); $i++ ) {
      $cmd += ( "\"" + liquidSlMethodName($i) + "\" " );
  }
  //trace $cmd;
  eval $cmd;

  // store the param names
  //
  string $cmd = ( "setAttr -type stringArray " + $node + ".rmanParams " + liquidSlNumParams() + " " );
  for ( $i = 0; $i < liquidSlNumParams(); $i++ ) {
      $cmd += ( "\"" + liquidSlParamName($i) + "\" " );
  }
  ////trace $cmd;
  eval $cmd;

  // store the param details
  //
  string $cmd = ( "setAttr -type stringArray " + $node + ".rmanDetails " + liquidSlNumParams() + " " );
  for ( $i = 0; $i < liquidSlNumParams(); $i++ ) {
      $cmd += ( liquidSlParamDetail($i) + " " );
  }
  ////trace $cmd;
  eval $cmd;

  // store the param types
  //
  string $cmd = ( "setAttr -type stringArray " + $node + ".rmanTypes " + liquidSlNumParams() + " " );
  for ( $i = 0; $i < liquidSlNumParams(); $i++ ) {
      $cmd += ( "\"" + liquidSlParamType($i) + "\" " );
  }
  ////trace $cmd;
  eval $cmd;

  // store the defaults
  //
  string $cmd = ( "setAttr -type stringArray " + $node + ".rmanDefaults " + liquidSlNumParams() + " " );
  for ( $i = 0; $i < liquidSlNumParams(); $i++ ) {
      if ( liquidSlParamType($i) == "string" ) $cmd += ( "\"" + liquidSlParamDefaultRaw($i) + "\" " );
      else $cmd += ( "\"" + liquidSlParamDefaultRaw($i) + "\" " );
  }
  ////trace $cmd;
  eval $cmd;

  // store the array sizes
  //
  string $cmd = ( "setAttr -type Int32Array " + $node + ".rmanArraySizes " + liquidSlNumParams() + " " );
  for ( $i = 0; $i < liquidSlNumParams(); $i++ ) {
      $cmd += ( liquidSlParamArraySize($i) + " " );
  }
  ////trace $cmd;
  eval $cmd;

  // store the lif command sequence
  //
  int $guiSize = ( liquidLifGuiSize() )? liquidLifGuiSize() : liquidSlNumParams();
  if ( !objExists( ($node + ".rmanLifCmds") ) ) addAttr -dt "stringArray" -ln rmanLifCmds $node;
  string $cmd = ( "setAttr -type stringArray " + $node + ".rmanLifCmds " + $guiSize + " " );
  for ( $i = 0; $i < $guiSize; $i++ ) {
      $cmd += ( "\"" + encodeString($gLifCmdList[$i]) + "\" " );
  }
  ////trace $cmd;
  eval $cmd;
  liqPopIdent();
}

global proc removeObsoleteParams( string $node )
{
  liqPushIdent();
	liqlog("removeObsoleteParams(...)");
  // delete obsolete params
  //
  global string $gLiquidSlParamNames[];
  string $allUserDefinedAttr[] = `listAttr -ud -hd $node`;
  string $obsoleteAttr[] = stringArrayRemove( $gLiquidSlParamNames, $allUserDefinedAttr );

  //trace ("[removeObsoleteParams] for "+$node);

  // remove obsolete attributes - that is the ones
  // that do not exist anymore.
  for ( $at in $obsoleteAttr ) 
  {
    string $fullattr = ( $node + "." + $at );

    // if we have a well-known attr, skip it.
    if (    $at == "rmanMethods"    ||
            $at == "rmanParams"     ||
            $at == "rmanDetails"    ||
            $at == "rmanTypes"      ||
            $at == "rmanDefaults"   ||
            $at == "rmanArraySizes" ||
            $at == "rmanLifCmds"    ||
          gmatch( $at, "liquid*ShaderNode")  ||
          gmatch( $at, "*Lif") ) continue;

    if ( objExists( $fullattr ) ) 
    {
      string $connections[] = `listConnections -plugs true $fullattr`;
      for ( $c in $connections ) 
      {
        //trace ("  disconnectAttr "+$c+" "+$fullattr);
        catch(`disconnectAttr $c $fullattr`);
      }
      string $parentAttr[] = `attributeQuery -n $node -listParent $at`;
      if ( !size($parentAttr) ) 
        deleteAttr $fullattr;
    }

  }

  // remove attributes whose type or size has changed
  liqPopIdent();
}


/**
 *  Here we check for false-positives : parameters with the same name
 *  but a different type or array size.
 *  This can be done only once the shader has been set.
 *  Modified to add suport for shader parameters and resizable arrays
 */
proc checkParamsDefinition( string $node )
{
  liqPushIdent();
	liqlog("checkParamsDefinition(...)");
	int $numOfArgs = liquidSlNumParams();

	//trace ("[checkParamsDefinition] for "+$node);

	for ( $i = 0; $i < $numOfArgs ; $i++ ) {

		string	$argName		= liquidSlParamName($i);
		string	$argType		= liquidSlParamType($i);
 		int		$argArrayLen	= liquidSlParamArraySize($i);
 		string	$plug			= ($node + "." + $argName );
 		
		if ( objExists( $plug ) ) {
			string $mayaType;
			switch( $argType ) {
				case "float":
					$mayaType = "double";
					break;
				case "shader":
				case "string":
					$mayaType = "string";
					break;
				case "color":
					$mayaType = "float3";
					break;
				case "point":
				case "normal":
				case "vector":
					$mayaType = "double3";
					break;
				default:
					break;
			}

			int $deleteAttr = 0;

			int $attrSize    = `getAttr -size $plug`;
	
			int $isArray = ($argArrayLen >= 0);
			int $resizable = ($argArrayLen == 0);
			// Non arrays have size of 1 in Maya
			int $definedSize = ($argArrayLen >= 0) ? $argArrayLen : 1;
	
			if ( !$resizable && ($definedSize != $attrSize) ) {
				//trace ("size : we must delete "+ $plug + " ( "+$argArrayLen+" != "+$attrSize+" )");
				$deleteAttr = 1;
			}

			string $attrType;
			if (!$isArray) {
			 	$attrType = `getAttr -type $plug`;
			} else {
				int $existingIndices[] = `getAttr -multiIndices  $plug`;
				if (size($existingIndices)) {
					$attrType = `getAttr -type ($plug+"["+$existingIndices[0]+"]")`;
				} else {
					$attrType = `getAttr -type ($plug+"[0]")`;
					// the above creates the multi instance so we need to remove it... Hopefully there is a cleanier way to this
					removeMultiInstance ($plug+"[0]");
				}	
			}
			if ( $mayaType != $attrType ) {
				//trace ("type : we must delete "+ $plug + " ( "+$mayaType+" != "+$attrType+" )");
				$deleteAttr = 1;
			}
	
			if ( $deleteAttr == 1 ) {
				//trace ("   >> deleted : "+ $plug);
				catch(`deleteAttr ($plug)`);
			}
		}
	}
  liqPopIdent();
}

/**
 *  Initialize shader parameters on shading node
 *  This proc will create all the shader attributes on the shader node.
 *  It will force re-parsing the shader, even if it has already been parsed
 *  In the end it will store parsed data for later reuse (rib gen)
 */
global proc liquidShaderNodes_initParams( string $nodeAttr )
{
  liqPushIdent();
	liqlog("liquidShaderNodes_initParams(...)");
  $node = basenameEx( $nodeAttr );
  string $shaderPath = `getAttr ($node+".rmanShaderLong")`;

  $shaderPath = `workspace -expandName $shaderPath`; // get absolute name from relative
  
  // shader does not exist / not readable
  if ( !`filetest -s $shaderPath` ) 
    warning ("[liquidShaderNodes_initParams] "+$shaderPath+" does not exist or is not readable");
  

  // invalid path
  if ( !liquidGlobalsExists() ) 
    eval("liquidCreateGlobals();select "+$node+";");
  string $extension = `getAttr "liquidGlobals.shaderExt"`;
  if ( ( match("[a-zA-Z]+$", $shaderPath ) != $extension ) && ( "" != $extension ) ) 
  {
    warning ("[liquidShaderNodes_initParams] Shaders must end with "+$extension+" ");
    liqPopIdent();
	return;
  }

  // read shader params
  liquidSlInfoReset();
  liquidSlSetShader( $shaderPath );

  // check the type
  string $shadertype = liquidSlShaderType();
  string $nodeType = nodeType( $node );
  $nodeType = tolower( $nodeType );
  //print("nodeType = " + $nodeType + "\n");
  //print("shadertype = " + $shadertype + "\n");
  if( $nodeType != "liquidcoshader" )  // accept everything
  {
	  if ( !gmatch( $nodeType,  ("*" + $shadertype + "*") ) ) {
		string $short = basenameEx( $shaderPath );
		string $typ = substitute("liquid", $nodeType, "" );
		warning ("[liquidShaderNodes_initParams] "+$short+" is not a "+$typ+" shader !");
		liqPopIdent();
		return;
	  }
  }

  // here we check for false-positives : parameters with the same name
  // but a different type or array size.
  // This can be done only once the shader has been set.
  checkParamsDefinition( $node );

  // create shader params
  liquidAttachShaderParams( $node, $shaderPath );

  // save the params description in a string array attribute
  rmanParams_create( $node, 0 );

  // delete obsolete params
  //
  // removeObsoleteParams( $node );
  
  global string $gLiquidSlParamNames[];
  string $allUserDefinedAttr[] = `listAttr -ud -hd $node`;
  string $obsoleteAttr[] = stringArrayRemove( $gLiquidSlParamNames, $allUserDefinedAttr );

  for ( $at in $obsoleteAttr ) 
  {
    string $fullattr = ($node+"."+$at);

  // if we have a well-known attr, skip it.
	// Added rmanMethods
    if (  $at == "rmanMethods"    ||
		  $at == "rmanParams"     ||
          $at == "rmanDetails"    ||
          $at == "rmanTypes"      ||
          $at == "rmanDefaults"   ||
          $at == "rmanArraySizes" ||
          $at == "rmanLifCmds" ||
          gmatch( $at, "liquid*ShaderNode")  ||
          gmatch( $at, "*Lif") ) continue;

    if ( objExists( $fullattr ) ) 
    {
      string $connections[] = `listConnections -plugs true $fullattr`;
      for ( $c in $connections ) 
      {
        //trace ("  disconnectAttr "+$c+" "+$fullattr);
        catch(`disconnectAttr $c $fullattr`);
      }
      string $parentAttr[] = `attributeQuery -n $node -listParent $at`;
      if ( !size($parentAttr) ) 
      deleteAttr $fullattr;
    }
  }
  //trace "[init] > done.";
  liqPopIdent();
}

/**
 *  Preview function for the shader node
 */
global proc liquidShaderNodePreview( string $node )
{
  liqPushIdent();
	liqlog("liquidShaderNodePreview(...)");
  if ( !liquidGlobalsExists() ) 
    eval("liquidCreateGlobals();select "+$node+";");

  string $nodetype = nodeType($node);
  if ( $nodetype == "liquidLight" || $nodetype == "liquidVolume" ) 
  {
    warning "[liquidShaderNodePreview] Preview is not yet supported for Liquid Light and Volume Shader.";
    liqPopIdent(); 
    return;
  }

  string $previewDir  = liquidFluidGetPreviewDir();
  string $shader      = getAttr ($node+".rmanShader");
  string $image       = ($previewDir+"/"+$node+"_"+$shader+".tif");

  // if a a previous .done file exists remove it.
  if ( `filetest -r ($image+"_"+$shader+".done")` ) 
    sysFile -del ($image+"_"+$shader+".done");

  string $args = ( "liquidPreviewShader -shader " + $node );
  int $previewType  = `getAttr liquidGlobals.previewType`;

  int $primitive;
  if ( objExists( ($node+".previewPrimitive") ) ) 
  {
    $primitive = `getAttr ($node+".previewPrimitive")`;
    if ( $primitive == "(globals)" ) 
      $primitive = `getAttr liquidGlobals.previewPrimitive`;
  } 
  else 
    $primitive = `getAttr liquidGlobals.previewPrimitive`;

  if( $primitive == 1 ) 
    $args += " -cube";
  else if( $primitive == 2 ) 
    $args += " -cylinder";
  else if( $primitive == 3 ) 
    $args += " -torus";
  else if( $primitive == 4 ) 
    $args += " -plane";
  else if( $primitive == 5 ) 
    $args += " -teapot";
  else if( $primitive == 6 ) 
  {
    $args += " -custom";
    string $customRibFile = `getAttr ($node+".previewCustomPrimitive")`;
    $args += ( " \""+$customRibFile+"\"");
  }

  if ( $nodetype == "liquidSurface" ) 
  {
    string $customBg = `getAttr ($node+".previewCustomBackplane")`;
    if ( $customBg != "" && !gmatch( $customBg, "*/") ) 
      $args += (" -cbk \"" + $customBg + "\"");
  }

  string $driver = ($previewType)? `getAttr liquidGlobals.previewDisplayDriver`:"tiff";
  if( $driver != "" ) 
    $args += " -dd " + $driver;

  $args += (" -dn \""+$image+"\"");

  int $type = ($previewType)? `getAttr liquidGlobals.previewConnectionType`:0;
  if( $type  == 1 ) 
    $args += " -pipe";

  int $size = ($previewType)? `getAttr liquidGlobals.previewSize`:128;
  $args += " -ds " + $size;

  int $sshn = `getAttr liquidGlobals.shortShaderNames`;
  if( $sshn != 0 ) 
    $args = $args + ( " -sshn " + $sshn );

  string $previewCommand = `getAttr liquidGlobals.previewRenderer`;
  if( $previewCommand != "" ) 
    $args = $args + ( " -renderer " + $previewCommand );

  float $objectSize = (objExists( ($node+".previewObjectSize") ))? (`getAttr ($node+".previewObjectSize")`):1.0;
  if( $objectSize != 1.0 ) 
    $args = $args + ( " -objectSize " + $objectSize );

  int $pixelSamples = (objExists( ($node+".previewPixelSamples") ))? (`getAttr ($node+".previewPixelSamples")`):3;
  if( $pixelSamples != 3 ) 
    $args = $args + ( " -pixelSamples " + $pixelSamples );

  float $shadingRate = (objExists( ($node+".previewShadingRate") ))? (`getAttr ($node+".previewShadingRate")`):1.0;
  if( $shadingRate != 1.0 ) 
    $args = $args + ( " -shadingRate " + $shadingRate );

  // Moritz: me thinks that attribute is only used for a custom backplane -- commented out.
  //int $backPlane = (objExists( ($node+".previewBackplane") ))? (`getAttr ($node+".previewBackplane")`):1;
  //if( $backPlane != 1 ) {
  //  $args = $args + ( " -noBackPlane" );
  //}

  float $intensityScale = (objExists( ($node+".previewIntensity") ))? (`getAttr ($node+".previewIntensity")`):1.0;
  $args = $args + ( " -previewIntensity " + $intensityScale );

  // run the command.
  eval( $args );

  // this will tell the node to reload the preview in the swatch
  setAttr ($node+".refreshPreview") true;
  liqPopIdent();
}

/**
 *  Make a bigger swatch ( 128x128 )
 */
global proc liquidPreviewSwatchNew ( string $nodeName, string $msg )
{
  liqPushIdent();
	liqlog("liquidPreviewSwatchNew(...)");
  global int $gTextColumnWidthIndex;

  string $node[];
  tokenize($msg, ".", $node);

  string $label = nodeType($node[0]);
  if ( gmatch( $label, "*Surface*") )           $label = "Surface";
  else if ( gmatch( $label, "*Displacement*") ) $label = "Displacement";
  else if ( gmatch( $label, "*Volume*") )       $label = "Volume";
  else if ( gmatch( $label, "*Light*") )        $label = "Light";

  formLayout swatchDisplayForm;
    text -l $label swatchLabel;

    swatchDisplayPort -wh 128 128 -sn $node[0] swatchDisplay;
    button -w 70 -h 64 -l "Preview"  liquidAEswatchRefresh;
    button -w 70 -h 28 -l "Reload"   liquidAEShaderReload;
    button -w 70 -h 28 -l "Edit LIF" liquidAEEditLif;
     button -w 70 -h 28 -l "Instance" liquidAEMakeInstance;
    button -w 70 -h 28 -l "Unnstance" liquidAEUninstance;

    setParent ..;
  formLayout -e
    -af  swatchLabel           top     0
    -af  swatchLabel           bottom  0
    -an  swatchLabel           left
    -aof swatchLabel           right   (-$gTextColumnWidthIndex)

    -ac  swatchDisplay         left    5   swatchLabel
    -af  swatchDisplay         top     0
    -an  swatchDisplay         right

    -af  liquidAEswatchRefresh top     -2
    -ac  liquidAEswatchRefresh left    5   swatchDisplay

    -af  liquidAEShaderReload  top     102
    -ac  liquidAEShaderReload  left    5   swatchDisplay

    -af  liquidAEEditLif       top     76
    -ac  liquidAEEditLif       left    5   swatchDisplay
    
    -aoc liquidAEMakeInstance    top     0   liquidAEEditLif 
    -aoc liquidAEMakeInstance    left    74  liquidAEEditLif
    
    -aoc liquidAEUninstance     top     0    liquidAEShaderReload
    -aoc liquidAEUninstance     left    74   liquidAEShaderReload
    
    swatchDisplayForm;

  liquidPreviewSwatchReplace $nodeName $msg;
  liqPopIdent();
}

/**
 *  Keep a bigger swatch
 */
global proc liquidPreviewSwatchReplace ( string $nodeName, string $msg )
{	
  liqPushIdent();
	liqlog("liquidPreviewSwatchReplace(...)");
  string $node[];
  tokenize($msg, ".", $node);

  string $label = nodeType($node[0]);
  if ( gmatch( $label, "*Surface*") )           $label = "surface";
  else if ( gmatch( $label, "*Displacement*") ) $label = "displacement";
  else if ( gmatch( $label, "*Volume*") )       $label = "volume";
  else if ( gmatch( $label, "*Light*") )        $label = "light";

  text -e -l $label swatchLabel;
  swatchDisplayPort -edit -sn $node[0] -wh 128 128 swatchDisplay;
  button -e -c ("liquidShaderNodePreview "+$node[0])            liquidAEswatchRefresh;
  button -e -c ("liquidShaderNodes_reloadAndRefresh "+$node[0]) liquidAEShaderReload;
  button -e -c ("liquidFluidEditLifFile \""+$node[0]+"\";")     liquidAEEditLif;

  //duran unuse this section
  //2.3.3 and mesh use this section
  int $enable = `objExists($node[0]+".liquidParentShader")`;
  button -e -c ("liquidShaderNodesMakeInstance\""+$node[0]+"\";") liquidAEMakeInstance;
  button -e -c ("liquidShaderNodesUninstance\""+$node[0]+"\";") -en ($enable)   liquidAEUninstance;
  liqPopIdent();
}

// AE procs

/**
 *  Return the name of a shader's cached layout.
 *  it uses the full path of the shader.
 *  "/tmp/test/version1/shaders/test.slo" will become "liquidSurface_tmp_test_version1_shaders_test_slo"
 */
global proc string liquidAE_getShaderLayoutName( string $nodeType, string $rmanShaderLong )
{	
  liqPushIdent();
	liqlog("liquidAE_getShaderLayoutName(...)");
  string $name = `substitute $rmanShaderLong "s/[\/\\. -]*/_/g"`;
  string $ret = $nodeType + basenameEx( $name );

  liqPopIdent();
  return $ret;
}

/**
 *  Returns the name of the cache layout.
 *  if need be the layout will be created here.
 */
global proc string liquidAE_setCacheLayout( string $parent, string $shaderType, string $rmanShaderLong )
{
  liqPushIdent();
	liqlog("liquidAE_setCacheLayout(...)");
  global string $gLiquid_currentAEShader;

  // create the base form layout if needed
  string $cacheLayout = ( $shaderType + "CachedLayouts" );
  if ( !`layout -q -ex $cacheLayout` ) 
    formLayout $cacheLayout;

  // set the parent to the base layout
  setParent $cacheLayout;

  // make the base layout invisible
  formLayout -e -vis 0 $cacheLayout;

  // make all layouts inside the formlayout non-managed
  string $cachedLayouts[] = `layout -q -ca $cacheLayout`;
  string $cl;
  for ( $cl in $cachedLayouts ) 
    layout -e -vis 0 -m 0 $cl;

  // create the shader layout if needed
  string $shaderLayout = liquidAE_getShaderLayoutName( $shaderType, $rmanShaderLong );
  if ( !`layout -q -ex $shaderLayout` ) 
    columnLayout -adj true -vis 0 -m 0 $shaderLayout;
  else 
    columnLayout -e -vis 0 -m 0 $shaderLayout;

  // remove oldest layout is we are beyond the limit set in the globals
  int $maxCachedLayouts = `getAttr liquidGlobals.shadersMaxCachedAELayouts`;
  string $allLayouts[] = `layout -q -ca $cacheLayout`;

  // note : we add 1 to $maxCachedLayouts because each layout cache contains an empty layout
  // for the case when the rmanShaderLong field is empty.
  if ( size( $allLayouts ) > $maxCachedLayouts+1 ) 
  {
    if ( $allLayouts[0] != $shaderType ) 
      deleteUI $allLayouts[0];
    else if ( $allLayouts[1] != "" ) 
      deleteUI $allLayouts[1];
  }

  // set the parent
  setParent $shaderLayout;

  $gLiquid_currentAEShader = $shaderLayout;

  liqPopIdent();
  return $shaderLayout;
}

/**
 *  Here we restore the visibility of the layout containing the shader's parameters.
 *  step:
 *      - get the name of the layout
 *      - make sure the layout is resized to fit all children
 *      - attach it to the base cache layout
 *      - make it visible
 */
global proc liquidAE_showCachedLayout( string $shaderType, string $rmanShaderLong )
{
  liqPushIdent();
	liqlog("liquidAE_showCachedLayout(...)");
  string $baseLayout = ( $shaderType + "CachedLayouts" );
  string $shaderLayout = liquidAE_getShaderLayoutName( $shaderType, $rmanShaderLong );


  // resize the layout
  string $children[] = `layout -q -ca $shaderLayout`;
  string $child;
  int $height = 1;
  for ( $child in $children ) 
    $height += `layout -q -h $child`;
  
  layout -e -h $height $shaderLayout;

  // attach it to the $baseLayout
  formLayout -e
             -af $shaderLayout top    0
             -af $shaderLayout left   0
             -af $shaderLayout right  0
             -af $shaderLayout bottom 0
             $baseLayout;

  // update the labels of
  // overriden string parameters
  liquidAE_LifStringOverrideDisplayAll();

  // set the layout state to managed and visible
  formLayout -e -vis 1 $baseLayout;
  layout -e -vis 1 -m 1 $shaderLayout;
  liqPopIdent();
}

/**
 *  This proc is basically empty.
 *  We don't use the Attribute Editor's layout cache, we build and manage our own layout cache.
 *  note: $msg contains the node.rmanShaderLong
 */
global proc liquidShaderNodesParamsNew ( string $msg )
{	
  liqPushIdent();
	liqlog("liquidShaderNodesParamsNew(...)");
  liquidShaderNodesParamsReplace( $msg );
  liqPopIdent();
}

/**
 *  display the shader parameters
 *  note: $msg contains the node.rmanShaderLong
 */
global proc liquidShaderNodesParamsReplace ( string $msg )
{
  liqPushIdent();
	liqlog("liquidShaderNodesParamsReplace(...)");
  float $st = `timerX`;

  //trace ("[liquidShaderNodesParamsReplace] for "+$msg);

  string $theNode        = basenameEx( $msg );
  string $nodeType       = nodeType( $theNode );
  string $longShaderName = getAttr( $msg );

  global string $gLiquid_currentAEParent;
  global string $gLiquid_currentAEShader;
  global string $gLiquid_currentAENode;
  global int	$gLiquid_maxDisplayElements = 20;

  $gLiquid_currentAENode = $theNode;
  if ( $gLiquid_currentAENode == "" ) 
    error ("[liquidShaderNodesParamsReplace] undefined current AE node !");

  // find the layout for the current shader
  $gLiquid_currentAEShader = liquidAE_getShaderLayoutName( $nodeType, $longShaderName );

  // store the current parent to restore it later
  string $topParent = `setParent -q`;

  // get our cache layout name
  $gLiquid_currentAEParent = liquidAE_setCacheLayout( $topParent, $nodeType, $longShaderName );

  setParent $gLiquid_currentAEParent;

  if ( objExists( ($theNode+".rmanLifCmds") ) ) 
  {
    string $cmds[] = `getAttr ($theNode+".rmanLifCmds")`;
    string $c;
    for ( $c in $cmds ) 
      if ( $c != "" ) 
        eval $c;
  } 
  else 
  {
    string $shaderLong = `getAttr ($theNode+".rmanShaderLong")`;
    if ( $shaderLong != "" ) 
    {
      // eventually re-parse the lif and generate the commands
      error( "[liquidShaderNodesParamsReplace] " + $msg + "-> no rmanLifCmds attr" );
    }
  }
  // restore le layout's visibility
  liquidAE_showCachedLayout( $nodeType, $longShaderName );
  setParent $topParent;
  string $time = `timerX -st $st`;
  //trace ("[liquidShaderNodesParamsReplace] DONE !  ( "+$time+" sec. )");
  liqPopIdent();
}

global proc liquidShaderNodesMakeInstance( string $node )
{
  liqPushIdent();
	liqlog("liquidShaderNodesMakeInstance(...)");
  // globals
  global string $gLiquidInheritedStandardShaderParams[] = {
	"color",
	"opacity",
	"Ci",
	"Oi",
	"shaderSpace",
	"displacementBound",
	"displacementBoundSpace",
	"outputInShadow"
  };

  string $nodeType = nodeType( $node );
  string $longShaderName = `getAttr ($node+".rmanShaderLong")`;

  string $prevSel[] = `ls -sl`;

  // grab the objects shader is assigned to
  liquidSelectShaderAssignedTo $node;

  // Create and instance a new node
  string $newNode  = `createNode $nodeType`;
  setAttr -type "string" ($newNode+".rmanShaderLong") $longShaderName;
  liquidShaderNodes_initParams($newNode);			// Is that right?
  
  liqlog("attaching " + $newNode + " to selection\n");
  
  if ( ! gmatch($nodeType,"liquid*") ) 
  {
  	liqlog( "Unknown parent shader type\n");
	liqPopIdent();
  	return;
  }
  
  // check if we have any shape selction
  string $shapeSel[] = `ls -sl -type shape -type transform`;
  if (size($shapeSel) == 0) 
  	select $shapeSel;
  
  string $shortType = substitute("liquid",$nodeType,"");
  string $cmd = "liquidAssign"+$shortType+"ShaderToSelected(\""+$newNode+"\")";
  
  select $prevSel;
  eval($cmd);

  // connect the shader attributes back
  string $params[] = `getAttr ($newNode+".rmanParams")`;
  for($i = 0; $i < size($params); $i++)
  {
  	liqlog("attaching " +($node+"."+$params[$i]) + " to " + ($newNode+"."+$params[$i]) + "\n");
		connectAttr ($node+"."+$params[$i]) ($newNode+"."+$params[$i]);
  }
  // connect the standard attributes back
  for($i = 0; $i < size($gLiquidInheritedStandardShaderParams); $i++) 
  	if (objExists($node+"."+$gLiquidInheritedStandardShaderParams[$i])) 
		  connectAttr ($node+"."+$gLiquidInheritedStandardShaderParams[$i]) ($newNode+"."+$gLiquidInheritedStandardShaderParams[$i]);
  
  // manage parent-child connectivity
  addAttr -ln "liquidParentShader" -at message $newNode;

  if (!objExists($node+".liquidChildShaders")) 
	  addAttr -m -im 0 -ln "liquidChildShaders" -at message $node;
  
  connectAttr -na ($newNode+".liquidParentShader") ($node+".liquidChildShaders");
  liqPopIdent();
}

global proc liquidShaderNodesUninstance( string $node )
{
  liqPushIdent();
	liqlog("liquidShaderNodesUninstance(...)");
  global string $gLiquidInheritedStandardShaderParams[];
  
  string $nodeType = nodeType( $node );
  string $longShaderName = `getAttr ($node+".rmanShaderLong")`;
  string $parentShader[] = `listConnections ($node+".liquidParentShader")`;
  
  if ( size($parentShader) <= 0 ) { liqPopIdent(); return; }

  string $params[] = `getAttr ($node+".rmanParams")`;
  for($i = 0; $i < size($params); $i++)
  {
  	liqlog("detaching " +($node+"."+$params[$i]) + "\n");
		if(`isConnected  ($parentShader[0]+"."+$params[$i]) ($node+"."+$params[$i])`) 
			disconnectAttr ($parentShader[0]+"."+$params[$i]) ($node+"."+$params[$i]);
  }
  // the standard ones
  for($i = 0; $i < size($gLiquidInheritedStandardShaderParams); $i++) 
  	if (objExists($node+"."+$gLiquidInheritedStandardShaderParams[$i])) 
		  disconnectAttr ($parentShader[0]+"."+$gLiquidInheritedStandardShaderParams[$i]) ($node+"."+$gLiquidInheritedStandardShaderParams[$i]);
  
  // find which element of the child array we were before we delete our source
  
  $parentShader = `listConnections -p 1 ($node+".liquidParentShader")`;
  
  // disconnect
  disconnectAttr ($node+".liquidParentShader") ($parentShader[0]);
  deleteAttr  ($node+".liquidParentShader");
  
  liqPopIdent();
}

/**
 * This proc will update the shader parameters of all children of a master shader
 * and then delete the corresponding cached layout to rebuild it.
 */
global proc liquidShaderNodes_reloadRecursive( string $node )
{
  liqPushIdent();
	liqlog("liquidShaderNodes_reloadRecursive(...)");
  string $oldParams[];
  string $newParams[];
  string $parentShader[];
  
  // If we are an instance, then either we should no longer be, or we must refresh the master shader
  if (objExists($node + ".liquidParentShader")) 
  {
  	 $parentShader = `listConnections ($node+".liquidParentShader")`;
  	 // remember our old param list
  	 $oldParams = `getAttr ($node+".rmanParams")`;
  }
  
  liquidShaderNodes_initParams( $node );
  
  if (objExists($node + ".liquidParentShader")) 
  {
    // grab any new parameters
    string $curParams[] = `getAttr ($parentShader[0]+".rmanParams")`;
    $newParams = stringArrayRemove ($oldParams,$curParams);
    
    // connect new parameters
    int $i;
    for($i = 0; $i < size($newParams); $i++) 
    {
      liqlog("attaching new parameter" +($parentShader[0]+"."+$newParams[$i]) + " to " + ($node+"."+$newParams[$i]) + "\n");
      connectAttr ($parentShader[0]+"."+$newParams[$i]) ($node+"."+$newParams[$i]);
    }
  }
  
  // delete the layouts
  string $nodeType = nodeType( $node );
  string $longShaderName = `getAttr ($node+".rmanShaderLong")`;
  string $cachedLayout = liquidAE_getShaderLayoutName( $nodeType, $longShaderName );
  if ( `layout -q -ex $cachedLayout` && size(`layout -q -ca $cachedLayout`) ) 
    deleteUI $cachedLayout;
  
  // refresh all children
  if (objExists($node+".liquidChildShaders")) 
  {
    string $children[] = `listConnections -s 1 -d 0 ($node+".liquidChildShaders")`;
    string $c;
    for( $c in $children ) liquidShaderNodes_reloadRecursive( $c );
  }
  liqPopIdent();
}

/**
 * This proc will update the shader parameters and then delete the corresponding cached layout to rebuild it.
 */
global proc liquidShaderNodes_reloadAndRefresh( string $node )
{
  liqPushIdent();
	liqlog("liquidShaderNodes_reloadAndRefresh(...)");
/*
  liquidShaderNodes_initParams( $node );
  string $nodeType = nodeType( $node );
  string $longShaderName = `getAttr ($node+".rmanShaderLong")`;
  string $cachedLayout = liquidAE_getShaderLayoutName( $nodeType, $longShaderName );
  if ( `layout -q -ex $cachedLayout` && size(`layout -q -ca $cachedLayout`) ) deleteUI $cachedLayout;
  liquidShaderNodesParamsReplace( ($node+".rmanShaderLong") );
*/
  string $oldParams[];
  string $newParams[];
  string $parentShader[];
  
  // If we are an instance, then either we should no longer be, or we must refresh the master shader
  if (objExists($node + ".liquidParentShader")) 
  {
    $parentShader = `listConnections ($node+".liquidParentShader")`;
    // remember our old param list
    $oldParams = `getAttr ($node+".rmanParams")`;
    
    // Check if we should be disconnecting (ie we now differ from the parent)
    if (`getAttr ($node+".rmanShaderLong")` != `getAttr ($parentShader[0]+".rmanShaderLong")`)
      liquidShaderNodesUninstance($node);
    else 
    { // otherwise find the root node refresh
      string $curNode = $parentShader[0];
      while (objExists($curNode + ".liquidParentShader")) 
      {
      	string $parNode[] = `listConnections ($curNode+".liquidParentShader")`;
      	$curNode = $parNode[0];
      }
      liquidShaderNodes_reloadRecursive($curNode);
    }
  }
  
  liquidShaderNodes_initParams( $node );
  
  if (objExists($node + ".liquidParentShader")) 
  {  
    // grab any new parameters
    string $curParams[] = `getAttr ($parentShader[0]+".rmanParams")`;
    $newParams = stringArrayRemove ($oldParams,$curParams);
    
    // connect new parameters
    int $i;
    for($i = 0; $i < size($newParams); $i++) 
    {
      liqlog("attaching new parameter" +($parentShader[0]+"."+$newParams[$i]) + " to " + ($node+"."+$newParams[$i]) + "\n");
      connectAttr ($parentShader[0]+"."+$newParams[$i]) ($node+"."+$newParams[$i]);
    }
  }
  
  // delete the layouts and refresh
  string $nodeType = nodeType( $node );
  string $longShaderName = `getAttr ($node+".rmanShaderLong")`;
  string $cachedLayout = liquidAE_getShaderLayoutName( $nodeType, $longShaderName );
  if ( `layout -q -ex $cachedLayout` && size(`layout -q -ca $cachedLayout`) ) 
    deleteUI $cachedLayout;
  liquidShaderNodesParamsReplace( ($node+".rmanShaderLong") );
  liqPopIdent();
}
/**
 *  Creates the shader selection field
 */
global proc liquidShaderPickerNew( string $nodeName, string $msg )
{
  liqPushIdent();
	liqlog("liquidShaderPickerNew(...)");
  if ( !liquidGlobalsExists() ) 
    liquidCreateGlobals();

  string $node[] = stringToStringArray( $msg, ".");
  $ctlName = ( "liquidShader_" + $node[1] );

  string $shaderDir  = getAttr("liquidGlobals.fluidShaderBrowserDefaultPath");
  if ( !gmatch( $shaderDir, "/*") ) 
    $shaderDir = (`workspace -q -rd` + $shaderDir);

  string $myFileCommand = ( "{\n"
                            + "string $v = `getAttr "+$msg+"`+\"\";"
                            + "liquidChangeTextFileAttrPlus " + $node[0] + " " + $node[1] + " " + $ctlName + " \"" + $shaderDir + "\" (\"*.\"+" + "`getAttr(\"liquidGlobals.shaderExt\")`" + ");"
                            + "if ( `getAttr "+$msg+"`+\"\" != $v ) evalDeferred(\"liquidShaderNodes_initParams " + $node[0] + "\");"
                            + "}");
  string $form          = `formLayout`;

  setUITemplate -pst attributeEditorTemplate;
  string $fullCtlPath   = `textFieldGrp -label "Shader" $ctlName`;
  connectControl -index 2 $fullCtlPath $msg;
  string $button = `iconTextButton -style "iconOnly" -w 29 -h 19 -mw 0 -mh 0 -i "lif_shd.xpm" -c $myFileCommand ($ctlName+"_button")`;
  setParent ..;

  if (`about -mac`) 
    formLayout  -e
                -af $ctlName  top     0
                -af $ctlName  left    0
                -af $ctlName  right   31
                -af $button   top     2
                -af $button   right   5
                $form;
  else 
    formLayout  -e
                -af $ctlName  top     0
                -af $ctlName  left    0
                -af $button   top     2
                -ac $button   left    0   $ctlName
                $form;

  setUITemplate -ppt;
  liqPopIdent();
}

/**
 *  Reconnects the shader selection field to the currently selected shader
 */
global proc liquidShaderPickerReplace( string $nodeName, string $msg )
{
  liqPushIdent();
	liqlog("liquidShaderPickerReplace(...)");
  if ( !liquidGlobalsExists() ) 
    liquidCreateGlobals();

  string $node[] = stringToStringArray( $msg, ".");
  $ctlName = ( "liquidShader_" + $node[1] );

  string $shaderDir  = getAttr("liquidGlobals.fluidShaderBrowserDefaultPath");
  if ( !gmatch( $shaderDir, "/*") ) 
    $shaderDir = (`workspace -q -rd` + $shaderDir);

  string $myFileCommand = (   "{\n"
                            + "string $v = `getAttr "+$msg+"`+\"\";"
                            + "liquidChangeTextFileAttrPlus " + $node[0] + " " + $node[1] + " " + $ctlName + " \"" + $shaderDir + "\" (\"*.\"+" + "`getAttr(\"liquidGlobals.shaderExt\")`" + ");"
                            + "if ( `getAttr "+$msg+"`+\"\" != $v ) evalDeferred(\"liquidShaderNodes_initParams " + $node[0] + "\");"
                            + "}");

  ////trace $myFileCommand;
  connectControl -index 2 $ctlName $msg;
  iconTextButton -e -c $myFileCommand ($ctlName+"_button");
  liqPopIdent();
}

/**
 *  The command that will be run after selecting a shader
 *  it store the shader path and creates the shader parameters on the node.
 */
global proc liquidShaderNode_loadCMD( string $nodeDotAttr, string $longShaderName )
{
  liqPushIdent();
	liqlog("liquidShaderNode_loadCMD(...)");
  setAttr -type "string" $nodeDotAttr $longShaderName;
  evalDeferred("liquidShaderNodes_initParams "+basenameEx($nodeDotAttr));
  liqPopIdent();
}

/**
 *  Build the custom primitive menu in the attribute editor.
 */
proc liquidShaderNodesCustomPrimitiveBuildCustomMenu( string $parent, string $nodeDotAttr )
{
  liqPushIdent();
	liqlog("liquidShaderNodesCustomPrimitiveBuildCustomMenu(...)");
  ////trace ($parent+"  "+$nodeDotAttr);
  string $attr = fileExtension($nodeDotAttr);
  string $ribPath;
  string $files[];

  switch( $attr ) 
  {
    case "previewCustomPrimitive":
      ////trace "prim";
      // get the list of available rib files in $LIQUIDHOME/previewRibFiles
      $ribPath = ( liquidGetHome() + "/lib/previewRibFiles/" );
      $files = `getFileList -fld $ribPath -fs "*.rib"`;
      break;
    case "previewCustomBackplane":
      ////trace "back";
      // get the list of available rib files in $LIQUIDHOME/previewRibFiles/backgrounds
      $ribPath = liquidGetHome() + "/lib/previewRibFiles/backgrounds/";
      $files = `getFileList -fld $ribPath -fs "*.rib"`;
      break;
    case "previewCustomLights":
      ////trace "light";
      // get the list of available rib files in $LIQUIDHOME/previewRibFiles/lights
      $ribPath = liquidGetHome() + "/lib/previewRibFiles/lights/";
      $files = `getFileList -fld $ribPath -fs "*.rib"`;
      break;
    default:
      break;
  }
  ////trace ("+ got "+size( $files )+" files" );

  // remove previous menu items
  string $items[] = `optionMenuGrp -q -ill ($parent)`;
  ////trace ("+ got "+size( $items )+" items" );
  for ( $it in $items ) deleteUI $it;

  // build the menu
  string $oldParent = `setParent -q`;
  string $fullParentPath = `setParent $parent`;

  string $currentCustomPrimitive = basenameEx(`getAttr $nodeDotAttr`);
  int $currentCustomPrimitiveIsListed = 0;

  // the list of rib files is stored in optionVars
  if ( `optionVar -ex ("liquid" + $attr)` ) 
    optionVar -clearArray ("liquid" + $attr);

  menuItem -p ($fullParentPath + "|OptionMenu") -l "none";
  for ( $f in $files ) 
  {
    string $label = basenameEx( $f );
    if ( $label == $currentCustomPrimitive ) 
      $currentCustomPrimitiveIsListed = 1;
    menuItem -p ($fullParentPath + "|OptionMenu") -l $label;
    optionVar -sva ("liquid" + $attr) ($ribPath + $f);
  }
  setParent $oldParent;

  // set the menu to the attribute's current value
  if ( $currentCustomPrimitiveIsListed ) 
    optionMenuGrp -e -v $currentCustomPrimitive $parent;
  else 
    setAttr -type "string" $nodeDotAttr "";
  liqPopIdent();
}

global proc liquidShaderNodesCustomPrimitiveNew( string $label, string $nodeDotAttr )
{
  liqPushIdent();
	liqlog("liquidShaderNodesCustomPrimitiveNew(...)");
  string $nodeType = nodeType( $nodeDotAttr );
  string $tokenized[] = stringToStringArray( $nodeDotAttr, ".");
  string $cltName = ($nodeType + "_" + $tokenized[1]);

  if ( !`optionMenuGrp -q -ex $cltName` ) 
  {
    setUITemplate -pst attributeEditorTemplate;
    optionMenuGrp -l $label $cltName;
    setUITemplate -ppt;
  }
  liquidShaderNodesCustomPrimitiveReplace( $label, $nodeDotAttr );
  liqPopIdent();
}

global proc liquidShaderNodesCustomPrimitiveReplace( string $label, string $nodeDotAttr )
{
  liqPushIdent();
	liqlog("liquidShaderNodesCustomPrimitiveReplace(...)");
  string $nodeType = nodeType( $nodeDotAttr );
  string $tokenized[] = stringToStringArray( $nodeDotAttr, ".");
  string $cltName = ($nodeType + "_" + $tokenized[1]);

  if ( `optionMenuGrp -q -ex $cltName` ) 
  {
    string $node[];
    tokenize $nodeDotAttr "." $node;
    string $cmd = ( "{"+
                    "   string $files[] = `optionVar -q liquid"+$tokenized[1]+"`;"+
                    "   int $sel = `optionMenuGrp -q -sl "+$cltName+"`;"+
                    "   //trace (\">>>> \"+$sel);"+
                    "   if ( $sel > 1 ) setAttr -type \"string\" "+$nodeDotAttr+" $files[$sel-2];"+
                    "   else setAttr -type \"string\" "+$nodeDotAttr+" \"\";"+
                    "}");
    optionMenuGrp -e -cc $cmd $cltName;
    liquidShaderNodesCustomPrimitiveBuildCustomMenu( $cltName, $nodeDotAttr );
  }
  ////trace ("liquidShaderNodesCustomPrimitiveReplace( "+ $nodeDotAttr +" )");
  liqPopIdent();
}

/**
 * Proc to attach a ribbox node to selected objects
 */
global proc liquidAssignRibboxToSelected( string $node )
{
  liqPushIdent();
	liqlog("liquidAssignRibboxToSelected(...)");
  string $selected[] = `ls -transforms -sl`;
  for ( $sel in $selected ) 
  {
    if ( !`attributeQuery -node $sel -ex "liqRIBBox"` ) 
      addAttr -ln "liqRIBBox" -dt "string" $sel;
    connectAttr -f ($node + ".ribbox") ($sel + ".liqRIBBox");
  }
  liqPopIdent();
}

global proc liquidSelectAssignedToRibbox( string $node )
{
  liqPushIdent();
	liqlog("liquidSelectAssignedToRibbox(...)");
  select (`listConnections ($node + ".ribbox")`);
  liqPopIdent();
}

/**
 *  proc to attach a liquidLight node to selected objects
 */
global proc liquidAssignLightShaderToSelected( string $node )
{
  liqPushIdent();
	liqlog("liquidAssignLightShaderToSelected(...)");
  string $selected[] = `ls -l -lights -dag -sl`;

  if ( !objExists( ($node + ".liqAssignedObjects") ) )
    addAttr -ln liqAssignedObjects -at message $node;

  for ( $sel in $selected ) 
  {
    if ( !objExists( ($sel + ".liquidLightShaderNode") ) ) 
      addAttr -ln liquidLightShaderNode -at message $sel;
    if ( !isConnected( ($node + ".liqAssignedObjects"), ($sel + ".liquidLightShaderNode" ) ) )
      connectAttr -f ($node + ".liqAssignedObjects") ($sel + ".liquidLightShaderNode");
  }
  liqPopIdent();
}

global proc liquidSelectAssignedToLightShader( string $node )
{
  liqPushIdent();
	liqlog("liquidSelectAssignedToLightShader(...)");
  select (`listConnections ($node+".liqAssignedObjects")`);
  liqPopIdent();
}

global proc liquidAssignSurfaceShaderToSelected( string $node )
{
  liqPushIdent();
	liqlog("liquidAssignSurfaceShaderToSelected(...)");
  // assign the shader to geometry
  if ( size(`ls -geometry -dag -sl`) ) 
    hyperShade -assign $node;

  // special case for nodes not supported by the hypershade
  string $selected[] = `ls  -type "stroke" // stroke = pfx
							              -type "pfxToon"
                            -type "pfxHair"
                            -type "locator"
                            -type "nurbsCurve"
                            -dag -sl`;
  ////trace (stringArrayToString( $selected, ", "));

  if ( !objExists( ($node+".liqAssignedObjects") ) )
    addAttr -ln liqAssignedObjects -at message $node;

  for ( $sel in $selected ) 
  {
    if ( !objExists( ($sel + ".liquidSurfaceShaderNode") ) )
      addAttr -ln liquidSurfaceShaderNode -at message $sel;
    if ( !isConnected( ($node + ".liqAssignedObjects"), ($sel + ".liquidSurfaceShaderNode" ) ) )
      connectAttr -f ($node + ".liqAssignedObjects") ($sel + ".liquidSurfaceShaderNode");
  }
  liqPopIdent();
}

global proc liquidAssignDisplacementShaderToSelected( string $node )
{
  liqPushIdent();
	liqlog("liquidAssignDisplacementShaderToSelected(...)");
  // assign the shader to geometry
  if ( size(`ls -geometry -dag -sl`) ) 
    hyperShade -assign $node;

  // special case for nodes not supported by the hypershade
  string $selected[] = `ls  -type "stroke" // stroke = pfx
							              -type "pfxToon"
                            -type "pfxHair"
                            -type "locator"
                            -type "nurbsCurve"
                            -dag -sl`;
  ////trace (stringArrayToString( $selected, ", "));

  if ( !objExists( ($node + ".liqAssignedObjects") ) )
      addAttr -ln liqAssignedObjects -at message $node;

  for ( $sel in $selected ) 
  {
    if ( !objExists( ($sel + ".liquidDispShaderNode") ) )
      addAttr -ln liquidSurfaceShaderNode -at message $sel;
    if ( !isConnected( ($node + ".liqAssignedObjects"), ($sel + ".liquidDispShaderNode" ) ) )
      connectAttr -f ($node + ".liqAssignedObjects") ($sel + ".liquidDispShaderNode");
  }
  liqPopIdent();
}

global proc liquidAssignVolumeShaderToSelected( string $node )
{
  liqPushIdent();
	liqlog("liquidAssignVolumeShaderToSelected(...)");
  // assign the shader to geometry
  if ( size(`ls -geometry -dag -sl`) ) 
    hyperShade -assign $node;

  // special case for nodes not supported by the hypershade
  string $selected[] = `ls  -type "stroke" // stroke = pfx
							              -type "pfxToon"
                            -type "pfxHair"
                            -type "locator"
                            -type "nurbsCurve"
                            -dag -sl`;
  ////trace (stringArrayToString( $selected, ", "));

  if ( !objExists( ($node + ".liqAssignedObjects") ) )
      addAttr -ln liqAssignedObjects -at message $node;

  for ( $sel in $selected ) 
  {
    if ( !objExists( ($sel + ".liquidVolumeShaderNode") ) )
      addAttr -ln liquidVolumeShaderNode -at message $sel;
    if ( !isConnected( ($node + ".liqAssignedObjects"), ($sel + ".liquidVolumeShaderNode" ) ) )
      connectAttr -f ($node+".liqAssignedObjects") ($sel+".liquidVolumeShaderNode");
  }
  liqPopIdent();
}

/**
 *  proc to select the objects assigned to a material or shading group
 */

global proc liquidSelectShaderAssignedTo( string $obj )
{
  liqPushIdent();
	liqlog("liquidSelectShaderAssignedTo(...)");
  ////trace $obj;
  string $selectionList[];
  string $objList[];
  if ( $obj == "" ) 
    $objList = `ls -sl -type liquidSurface -type liquidDisplacement -type liquidVolume -type shadingEngine`;
  else 
    $objList = stringToStringArray( $obj, " ");
  select -clear;
  for ( $o in $objList ) 
  {
    string $shadingGroups[];
    if ( nodeType($o) == "shadingEngine" ) 
      $shadingGroups[0] = $o;
    else 
      $shadingGroups = `listConnections -d true -s false -type shadingEngine $o`;

    for ( $sg in $shadingGroups ) 
    {
      string $connections[] = `listConnections -d false -s true -plugs true $sg`;
      for ( $c in $connections ) 
      {
        if ( gmatch( $c, "*.instObjGroups") ) 
        {
          string $transform[] = `listRelatives -p -pa (basenameEx($c))`;
          $selectionList[size( $selectionList )] = $transform[0];
        }
      }
    }

    if ( objExists( ($o + ".liqAssignedObjects") ) ) 
    {
      string $connected[] = `listConnections -d true -s false ($o+".liqAssignedObjects")`;
      for ( $cc in $connected ) $selectionList[size( $selectionList )] = $cc;
    }
  }
  select $selectionList;
  liqPopIdent();
}

/**
 *  assign shaders in the hypershade
 */
global proc liquidAssignShaderToSelected( string $node )
{
  liqPushIdent();
	liqlog("liquidAssignShaderToSelected(...)");
  string $nodetype = nodeType($node);
  if      ( $nodetype == "liquidLight" ) liquidAssignLightShaderToSelected( $node );
  else if ( $nodetype == "liquidSurface" ) liquidAssignSurfaceShaderToSelected( $node );
  else if ( $nodetype == "liquidDisplacement" ) liquidAssignDisplacementShaderToSelected( $node );
  else if ( $nodetype == "liquidVolume" ) liquidAssignVolumeShaderToSelected( $node );

  liqPopIdent();
}

/**
 *  update all nodes for the AE optimization.
 */
global proc liquidShaderUpdater( int $force )
{
//  ////trace ("liquidShaderUpdater( "+$force+" )");
//  string $shaderNodes[] = `ls -type liquidSurface -type liquidDisplacement -type liquidVolume -type liquidLight`;
//  if ( !size( $shaderNodes ) ) {
//    ////trace "nothing";
//    return;
//  }
//  for ( $node in $shaderNodes ) {
//    string $longShaderName = `getAttr ($node+".rmanShaderLong")`;
//    if ( $longShaderName == "" ) continue;
//    if ( !`filetest -r $longShaderName` ) error("[liquidShaderUpdater] could not find shader \""+$longShaderName+"\"");
//    int $numParams = size( `getAttr ($node+".rmanParams")` );
//    if ( $force ||
//        size( `getAttr ($node+".rmanDetails")` ) != $numParams ||
//        size( `getAttr ($node+".rmanTypes")` ) != $numParams ||
//        size( `getAttr ($node+".rmanDefaults")` ) != $numParams ||
//        size( `getAttr ($node+".rmanArraySizes")` ) != $numParams
//       ) {
//      //trace ("liquidShaderUpdater : updating liquid shader "+$node);
//      rmanParams_create( $node, 1 );
//    }
//  }
}


{
	liqDebug(" Warning: How we get here?");
  string $jobs[] = `scriptJob -lj`;
  string $j;
  for ( $j in $jobs ) 
    if ( gmatch( $j, "*liquidShaderUpdater*") ) 
      scriptJob -kill (int(match("[0-9]+", $j))) -force;
  
  scriptJob -event "SceneOpened" "evalDeferred(\"liquidShaderUpdater 1\")" -protected;
}

